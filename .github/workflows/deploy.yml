# Glassbox CI/CD Pipeline
# Builds Docker images, pushes to GitHub Container Registry, and deploys to AWS Lightsail
#
# Required GitHub Secrets:
# - LIGHTSAIL_SSH_KEY: Private SSH key for Lightsail instance
# - LIGHTSAIL_HOST: IP address or hostname of Lightsail instance
# - LIGHTSAIL_USER: SSH username (typically 'ubuntu')

name: Build and Deploy

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:

# Ensure only one deployment runs at a time
concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

env:
  REGISTRY: ghcr.io
  FRONTEND_IMAGE: ghcr.io/${{ github.repository }}/frontend
  BACKEND_IMAGE: ghcr.io/${{ github.repository }}/backend
  DEPLOY_PATH: ${{ vars.DEPLOY_PATH || '/opt/glassbox' }}

jobs:
  # Job 1: Run tests and linting
  test:
    name: Test & Lint
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v3
        with:
          version: 9.2.0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run type check
        run: pnpm run type-check
        continue-on-error: true

      - name: Run linting
        run: pnpm run lint
        continue-on-error: true

  # Job 2: Build and push Docker images
  build:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: [test]
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped')

    permissions:
      contents: read
      packages: write

    env:
      BUILDKIT_PROGRESS: plain

    outputs:
      frontend_image: ${{ steps.meta-frontend.outputs.tags }}
      backend_image: ${{ steps.meta-backend.outputs.tags }}
      version: ${{ steps.version.outputs.version }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate version
        id: version
        run: |
          VERSION="${{ github.sha }}"
          SHORT_SHA="${VERSION:0:7}"
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          echo "version=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "timestamp=${TIMESTAMP}" >> $GITHUB_OUTPUT
          echo "Generated version: ${SHORT_SHA}"

      # Frontend image metadata
      - name: Extract frontend metadata
        id: meta-frontend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.FRONTEND_IMAGE }}
          tags: |
            type=sha,prefix=
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ steps.version.outputs.version }}

      # Backend image metadata
      - name: Extract backend metadata
        id: meta-backend
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.BACKEND_IMAGE }}
          tags: |
            type=sha,prefix=
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ steps.version.outputs.version }}

      # Build and push frontend image
      - name: Build and push frontend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/web/Dockerfile
          push: true
          tags: ${{ steps.meta-frontend.outputs.tags }}
          labels: ${{ steps.meta-frontend.outputs.labels }}
          cache-from: type=gha,scope=frontend
          cache-to: type=gha,mode=max,scope=frontend
          build-args: |
            NEXT_PUBLIC_API_URL=${{ vars.NEXT_PUBLIC_API_URL || 'https://api.example.com' }}

      # Build and push backend image
      - name: Build and push backend image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/backend/Dockerfile
          push: true
          tags: ${{ steps.meta-backend.outputs.tags }}
          labels: ${{ steps.meta-backend.outputs.labels }}
          cache-from: type=gha,scope=backend
          cache-to: type=gha,mode=max,scope=backend

      - name: Image build summary
        run: |
          echo "### Docker Images Built" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Image | Tags |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|------|" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend | ${{ steps.meta-frontend.outputs.tags }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Backend | ${{ steps.meta-backend.outputs.tags }} |" >> $GITHUB_STEP_SUMMARY

  # Job 3: Deploy to Lightsail
  deploy:
    name: Deploy to Lightsail
    runs-on: ubuntu-latest
    needs: [build]
    if: success()

    environment:
      name: production
      url: ${{ vars.APP_URL || 'https://example.com' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.LIGHTSAIL_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.LIGHTSAIL_HOST }} >> ~/.ssh/known_hosts 2>/dev/null || true

      - name: Create deployment script
        run: |
          cat << 'DEPLOY_SCRIPT' > deploy.sh
          #!/bin/bash
          set -e

          # Configuration
          DEPLOY_PATH="${DEPLOY_PATH:-/opt/glassbox}"
          FRONTEND_IMAGE="${FRONTEND_IMAGE}"
          BACKEND_IMAGE="${BACKEND_IMAGE}"
          VERSION="${VERSION}"

          echo "=== Glassbox Deployment ==="
          echo "Version: ${VERSION}"
          echo "Frontend: ${FRONTEND_IMAGE}"
          echo "Backend: ${BACKEND_IMAGE}"
          echo "Deploy Path: ${DEPLOY_PATH}"
          echo ""

          # Navigate to deployment directory
          cd "${DEPLOY_PATH}"

          # Log in to GitHub Container Registry
          echo "Logging in to GitHub Container Registry..."
          echo "${GHCR_TOKEN}" | docker login ghcr.io -u "${GITHUB_ACTOR}" --password-stdin

          # Pull new images
          echo "Pulling new images..."
          docker pull "${FRONTEND_IMAGE}:${VERSION}" || docker pull "${FRONTEND_IMAGE}:latest"
          docker pull "${BACKEND_IMAGE}:${VERSION}" || docker pull "${BACKEND_IMAGE}:latest"

          # Tag images for docker-compose
          docker tag "${FRONTEND_IMAGE}:${VERSION}" "${FRONTEND_IMAGE}:deploy" 2>/dev/null || \
          docker tag "${FRONTEND_IMAGE}:latest" "${FRONTEND_IMAGE}:deploy"

          docker tag "${BACKEND_IMAGE}:${VERSION}" "${BACKEND_IMAGE}:deploy" 2>/dev/null || \
          docker tag "${BACKEND_IMAGE}:latest" "${BACKEND_IMAGE}:deploy"

          # Backup current state
          echo "Creating deployment backup..."
          BACKUP_FILE="backup_$(date +%Y%m%d_%H%M%S).tar.gz"
          docker-compose exec -T postgres pg_dump -U glassbox glassbox 2>/dev/null | gzip > "backups/${BACKUP_FILE}" || echo "Backup skipped (no existing database)"

          # Stop and update services
          echo "Updating services..."
          docker-compose pull 2>/dev/null || true
          docker-compose up -d --no-deps --build backend

          # Wait for backend to be healthy
          echo "Waiting for backend to be healthy..."
          for i in {1..30}; do
            if docker-compose exec -T backend wget -q --spider http://localhost:4000/health 2>/dev/null; then
              echo "Backend is healthy!"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "ERROR: Backend health check failed after 30 attempts"
              exit 1
            fi
            echo "Waiting for backend... (attempt $i/30)"
            sleep 2
          done

          # Run database migrations
          echo "Running database migrations..."
          docker-compose exec -T backend npx prisma migrate deploy || echo "Migration skipped or already up to date"

          # Update frontend
          echo "Updating frontend..."
          docker-compose up -d --no-deps frontend

          # Wait for frontend
          echo "Waiting for frontend to be ready..."
          for i in {1..20}; do
            if docker-compose exec -T frontend wget -q --spider http://localhost:3000 2>/dev/null; then
              echo "Frontend is ready!"
              break
            fi
            if [ $i -eq 20 ]; then
              echo "WARNING: Frontend health check timed out"
            fi
            echo "Waiting for frontend... (attempt $i/20)"
            sleep 2
          done

          # Reload nginx
          echo "Reloading nginx..."
          docker-compose exec -T nginx nginx -s reload 2>/dev/null || docker-compose restart nginx

          # Cleanup old images
          echo "Cleaning up old images..."
          docker image prune -f --filter "until=24h"

          # Final health check
          echo ""
          echo "=== Deployment Complete ==="
          docker-compose ps
          echo ""
          echo "Service Status:"
          docker-compose exec -T backend wget -q -O- http://localhost:4000/health 2>/dev/null || echo "Backend: Check manually"

          DEPLOY_SCRIPT
          chmod +x deploy.sh

      - name: Deploy to Lightsail
        env:
          FRONTEND_IMAGE: ${{ env.FRONTEND_IMAGE }}
          BACKEND_IMAGE: ${{ env.BACKEND_IMAGE }}
          VERSION: ${{ needs.build.outputs.version }}
          GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_ACTOR: ${{ github.actor }}
        run: |
          # Copy deployment script
          scp -o StrictHostKeyChecking=no deploy.sh ${{ secrets.LIGHTSAIL_USER }}@${{ secrets.LIGHTSAIL_HOST }}:/tmp/deploy.sh

          # Execute deployment
          ssh -o StrictHostKeyChecking=no ${{ secrets.LIGHTSAIL_USER }}@${{ secrets.LIGHTSAIL_HOST }} \
            "DEPLOY_PATH='${{ env.DEPLOY_PATH }}' \
             FRONTEND_IMAGE='${FRONTEND_IMAGE}' \
             BACKEND_IMAGE='${BACKEND_IMAGE}' \
             VERSION='${VERSION}' \
             GHCR_TOKEN='${GHCR_TOKEN}' \
             GITHUB_ACTOR='${GITHUB_ACTOR}' \
             bash /tmp/deploy.sh"

      - name: Verify deployment
        run: |
          echo "Verifying deployment..."
          sleep 10

          # Health check via SSH
          ssh -o StrictHostKeyChecking=no ${{ secrets.LIGHTSAIL_USER }}@${{ secrets.LIGHTSAIL_HOST }} \
            "curl -sf http://localhost:4000/health || echo 'Health check endpoint not responding'"

      - name: Deployment summary
        if: always()
        run: |
          echo "### Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | production |" >> $GITHUB_STEP_SUMMARY
          echo "| Version | ${{ needs.build.outputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Status | ${{ job.status }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Deployed At | $(date -u +"%Y-%m-%d %H:%M:%S UTC") |" >> $GITHUB_STEP_SUMMARY

  # Job 4: Post-deployment health check
  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: [deploy]
    if: success()

    steps:
      - name: Wait for services to stabilize
        run: sleep 30

      - name: Check application health
        run: |
          APP_URL="${{ vars.APP_URL || 'https://example.com' }}"
          API_URL="${{ vars.NEXT_PUBLIC_API_URL || 'https://api.example.com' }}"

          echo "Checking frontend at ${APP_URL}..."
          FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${APP_URL}" || echo "000")

          echo "Checking backend health at ${API_URL}/health..."
          BACKEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${API_URL}/health" || echo "000")

          echo ""
          echo "=== Health Check Results ==="
          echo "Frontend: ${FRONTEND_STATUS}"
          echo "Backend: ${BACKEND_STATUS}"

          if [ "$FRONTEND_STATUS" != "200" ] && [ "$FRONTEND_STATUS" != "304" ]; then
            echo "WARNING: Frontend returned non-200 status"
          fi

          if [ "$BACKEND_STATUS" != "200" ]; then
            echo "WARNING: Backend health check returned non-200 status"
          fi

          # Generate summary
          echo "### Health Check Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Service | Status | URL |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|--------|-----|" >> $GITHUB_STEP_SUMMARY
          echo "| Frontend | ${FRONTEND_STATUS} | ${APP_URL} |" >> $GITHUB_STEP_SUMMARY
          echo "| Backend | ${BACKEND_STATUS} | ${API_URL}/health |" >> $GITHUB_STEP_SUMMARY

